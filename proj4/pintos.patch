diff -ruN aos_pintos/src/examples/Makefile pintos-solution/src/examples/Makefile
--- aos_pintos/src/examples/Makefile	2025-04-28 15:48:15.672391363 +0000
+++ pintos-solution/src/examples/Makefile	2025-04-27 21:48:39.454134580 +0000
@@ -4,7 +4,7 @@
 # To add a new test, put its name on the PROGS list
 # and then add a name_SRC line that lists its source files.
 PROGS = cat cmp cp echo halt hex-dump ls mkdir pwd rm shell \
-	bubsort lineup matmult recursor
+	bubsort lineup matmult recursor swap_test test
 
 # Should work from project 2 onward.
 cat_SRC = cat.c
@@ -17,6 +17,8 @@
 ls_SRC = ls.c
 recursor_SRC = recursor.c
 rm_SRC = rm.c
+swap_test_SRC = swap_test.c
+test_SRC = test.c
 
 # Should work in project 3; also in project 4 if VM is included.
 bubsort_SRC = bubsort.c
diff -ruN aos_pintos/src/filesys/Make.vars pintos-solution/src/filesys/Make.vars
--- aos_pintos/src/filesys/Make.vars	2025-04-28 15:48:15.672391363 +0000
+++ pintos-solution/src/filesys/Make.vars	2025-04-27 21:48:39.458134580 +0000
@@ -1,8 +1,9 @@
 # -*- makefile -*-
 
-kernel.bin: DEFINES = -DUSERPROG -DFILESYS
+kernel.bin: DEFINES = -DUSERPROG -DFILESYS -DVM
 KERNEL_SUBDIRS = threads devices lib lib/kernel userprog filesys
 TEST_SUBDIRS = tests/userprog tests/filesys/base tests/filesys/extended
 GRADING_FILE = $(SRCDIR)/tests/filesys/Grading
 SIMULATOR = --qemu
+KERNEL_SUBDIRS += vm
 
diff -ruN aos_pintos/src/filesys/directory.c pintos-solution/src/filesys/directory.c
--- aos_pintos/src/filesys/directory.c	2025-04-28 15:48:15.672391363 +0000
+++ pintos-solution/src/filesys/directory.c	2025-04-27 21:48:39.458134580 +0000
@@ -1,4 +1,4 @@
-#include "filesys/directory.h"
+ #include "filesys/directory.h"
 #include <stdio.h>
 #include <string.h>
 #include <list.h>
@@ -23,17 +23,54 @@
 
 /* Creates a directory with space for ENTRY_CNT entries in the
    given SECTOR.  Returns true if successful, false on failure. */
-bool dir_create (block_sector_t sector, size_t entry_cnt)
-{
-  return inode_create (sector, entry_cnt * sizeof (struct dir_entry));
+bool dir_create (block_sector_t sector, size_t entry_cnt, block_sector_t parent_sector) {
+  // Create inode for directory, mark it as a directory type
+  if (!inode_create (sector, entry_cnt * sizeof (struct dir_entry), true)) {
+    return false;
+  }
+
+  struct dir *dir = dir_open(inode_open(sector));
+  if (dir == NULL)
+    return false;
+
+  // Add '.' pointing to self
+  struct dir_entry dot_entry;
+  memset(&dot_entry, 0, sizeof dot_entry);
+  dot_entry.in_use = true;
+  strlcpy(dot_entry.name, ".", NAME_MAX + 1);
+  dot_entry.inode_sector = sector;
+
+  if (inode_write_at(dir->inode, &dot_entry, sizeof dot_entry, 0) != sizeof dot_entry) {
+    dir_close(dir);
+    return false;
+  }
+
+  // Add '..' pointing to parent
+  struct dir_entry dotdot_entry;
+  memset(&dotdot_entry, 0, sizeof dotdot_entry);
+  dotdot_entry.in_use = true;
+  strlcpy(dotdot_entry.name, "..", NAME_MAX + 1);
+  dotdot_entry.inode_sector = parent_sector;
+
+  if (inode_write_at(dir->inode, &dotdot_entry, sizeof dotdot_entry, sizeof dot_entry) != sizeof dotdot_entry) {
+    dir_close(dir);
+    return false;
+  }
+
+  dir_close(dir);
+  return true;
 }
 
 /* Opens and returns the directory for the given INODE, of which
    it takes ownership.  Returns a null pointer on failure. */
 struct dir *dir_open (struct inode *inode)
 {
+  if (inode == NULL || !inode_is_dir(inode)){
+    inode_close(inode);
+    return NULL;
+  }
   struct dir *dir = calloc (1, sizeof *dir);
-  if (inode != NULL && dir != NULL)
+  if (dir != NULL)
     {
       dir->inode = inode;
       dir->pos = 0;
@@ -132,36 +169,40 @@
   off_t ofs;
   bool success = false;
 
-  ASSERT (dir != NULL);
-  ASSERT (name != NULL);
+  ASSERT(dir != NULL);
+  ASSERT(name != NULL);
 
   /* Check NAME for validity. */
-  if (*name == '\0' || strlen (name) > NAME_MAX)
+  if (*name == '\0' || strlen(name) > NAME_MAX)
     return false;
 
   /* Check that NAME is not in use. */
-  if (lookup (dir, name, NULL, NULL))
+  if (lookup(dir, name, NULL, NULL))
     goto done;
 
-  /* Set OFS to offset of free slot.
-     If there are no free slots, then it will be set to the
-     current end-of-file.
-
-     inode_read_at() will only return a short read at end of file.
-     Otherwise, we'd need to verify that we didn't get a short
-     read due to something intermittent such as low memory. */
-  for (ofs = 0; inode_read_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
+  /* Set OFS to offset of free slot. */
+  for (ofs = 0; inode_read_at(dir->inode, &e, sizeof e, ofs) == sizeof e;
        ofs += sizeof e)
     if (!e.in_use)
       break;
 
-  /* Write slot. */
+  /* Write directory entry. */
   e.in_use = true;
-  strlcpy (e.name, name, sizeof e.name);
+  strlcpy(e.name, name, sizeof e.name);
   e.inode_sector = inode_sector;
-  success = inode_write_at (dir->inode, &e, sizeof e, ofs) == sizeof e;
+  success = inode_write_at(dir->inode, &e, sizeof e, ofs) == sizeof e;
+
+  /* If it's a directory, set up "." and ".." entries */
+  if (success && inode_is_dir(inode_open(inode_sector))) {
+    struct dir *subdir = dir_open(inode_open(inode_sector));
+    if (subdir != NULL) {
+      dir_add(subdir, ".", inode_sector);                          // self
+      dir_add(subdir, "..", inode_get_inumber(dir->inode));       // parent
+      dir_close(subdir);
+    }
+  }
 
-done:
+ done:
   return success;
 }
 
diff -ruN aos_pintos/src/filesys/directory.h pintos-solution/src/filesys/directory.h
--- aos_pintos/src/filesys/directory.h	2025-04-28 15:48:15.672391363 +0000
+++ pintos-solution/src/filesys/directory.h	2025-04-27 21:48:39.458134580 +0000
@@ -14,7 +14,7 @@
 struct inode;
 
 /* Opening and closing directories. */
-bool dir_create (block_sector_t sector, size_t entry_cnt);
+bool dir_create (block_sector_t sector, size_t entry_cnt, block_sector_t parent_sector);
 struct dir *dir_open (struct inode *);
 struct dir *dir_open_root (void);
 struct dir *dir_reopen (struct dir *);
diff -ruN aos_pintos/src/filesys/filesys.c pintos-solution/src/filesys/filesys.c
--- aos_pintos/src/filesys/filesys.c	2025-04-28 15:48:15.672391363 +0000
+++ pintos-solution/src/filesys/filesys.c	2025-04-28 03:44:54.983079430 +0000
@@ -42,7 +42,7 @@
   block_sector_t inode_sector = 0;
   struct dir *dir = dir_open_root ();
   bool success = (dir != NULL && free_map_allocate (1, &inode_sector) &&
-                  inode_create (inode_sector, initial_size) &&
+                  inode_create (inode_sector, initial_size, false) &&
                   dir_add (dir, name, inode_sector));
   if (!success && inode_sector != 0)
     free_map_release (inode_sector, 1);
@@ -116,8 +116,8 @@
 {
   printf ("Formatting file system...");
   free_map_create ();
-  if (!dir_create (ROOT_DIR_SECTOR, 16))
+  if (!dir_create (ROOT_DIR_SECTOR, 16, ROOT_DIR_SECTOR))
     PANIC ("root directory creation failed");
   free_map_close ();
   printf ("done.\n");
-}
\ No newline at end of file
+}
diff -ruN aos_pintos/src/filesys/free-map.c pintos-solution/src/filesys/free-map.c
--- aos_pintos/src/filesys/free-map.c	2025-04-28 15:48:15.672391363 +0000
+++ pintos-solution/src/filesys/free-map.c	2025-04-28 03:45:40.050945525 +0000
@@ -5,6 +5,14 @@
 #include "filesys/filesys.h"
 #include "filesys/inode.h"
 
+// #define FREE_MAP_DEBUG
+
+#ifdef FREE_MAP_DEBUG
+#define dprintf(...) printf(__VA_ARGS__)
+#else
+#define dprintf(...) ((void)0)
+#endif
+
 static struct file *free_map_file; /* Free map file. */
 static struct bitmap *free_map;    /* Free map, one bit per sector. */
 
@@ -48,11 +56,19 @@
 /* Opens the free map file and reads it from disk. */
 void free_map_open (void)
 {
+
+  dprintf("[free_map_open] Opening free map at sector %d\n", FREE_MAP_SECTOR);
+  
   free_map_file = file_open (inode_open (FREE_MAP_SECTOR));
   if (free_map_file == NULL)
     PANIC ("can't open free map");
+
+  dprintf("[free_map_open] Successfully opened free map file. Now reading bitmap...\n");
+  
   if (!bitmap_read (free_map, free_map_file))
     PANIC ("can't read free map");
+
+  dprintf("[free_map_open] Successfully read free map bitmap from disk.\n");
 }
 
 /* Writes the free map to disk and closes the free map file. */
@@ -63,7 +79,10 @@
 void free_map_create (void)
 {
   /* Create inode. */
-  if (!inode_create (FREE_MAP_SECTOR, bitmap_file_size (free_map)))
+
+  dprintf("[free_map_create] bitmap_file_size = %d\n", bitmap_file_size(free_map));
+  
+  if (!inode_create (FREE_MAP_SECTOR, bitmap_file_size (free_map), false))
     PANIC ("free map creation failed");
 
   /* Write bitmap to file. */
diff -ruN aos_pintos/src/filesys/inode.c pintos-solution/src/filesys/inode.c
--- aos_pintos/src/filesys/inode.c	2025-04-28 15:48:15.672391363 +0000
+++ pintos-solution/src/filesys/inode.c	2025-04-28 13:57:41.222051636 +0000
@@ -7,19 +7,41 @@
 #include "filesys/free-map.h"
 #include "threads/malloc.h"
 
+// #define INODE_DEBUG
+
+#ifdef INODE_DEBUG
+#define dprintf(...) printf(__VA_ARGS__)
+#else
+#define dprintf(...) ((void)0)
+#endif
+
 /* Identifies an inode. */
 #define INODE_MAGIC 0x494e4f44
 
+#define DIRECT_BLOCKS 12
+#define INDIRECT_BLOCKS 1
+#define DOUBLE_INDIRECT_BLOCKS 1
+
+#define PTRS_PER_BLOCK (BLOCK_SECTOR_SIZE / sizeof(block_sector_t))
+
 /* On-disk inode.
    Must be exactly BLOCK_SECTOR_SIZE bytes long. */
 struct inode_disk
 {
-  block_sector_t start; /* First data sector. */
+  block_sector_t direct[DIRECT_BLOCKS]; /* First data sector. */
+  block_sector_t indirect;
+  block_sector_t double_indirect;
   off_t length;         /* File size in bytes. */
   unsigned magic;       /* Magic number. */
   bool is_symlink;      /* True if symbolic link, false otherwise. */
-  uint32_t unused[124]; /* Not used. */
-};
+  bool is_dir;
+  uint8_t unused[BLOCK_SECTOR_SIZE
+		 - (DIRECT_BLOCKS * sizeof(block_sector_t))
+		 - 2 * sizeof(block_sector_t)
+		 - sizeof(off_t)
+		 - sizeof(unsigned)
+		 - 2 * sizeof(bool)];
+}__attribute__((packed));
 
 /* Returns the number of sectors to allocate for an inode SIZE
    bytes long. */
@@ -46,10 +68,42 @@
 static block_sector_t byte_to_sector (const struct inode *inode, off_t pos)
 {
   ASSERT (inode != NULL);
-  if (pos < inode->data.length)
-    return inode->data.start + pos / BLOCK_SECTOR_SIZE;
-  else
-    return -1;
+  if (pos >= inode->data.length)
+    return (block_sector_t) -1;
+
+  off_t index = pos / BLOCK_SECTOR_SIZE;
+
+  if((size_t)index < DIRECT_BLOCKS){
+    return inode->data.direct[index];
+  }
+
+  index -= DIRECT_BLOCKS;
+  if((size_t)index < PTRS_PER_BLOCK) {
+    block_sector_t indirect_block[PTRS_PER_BLOCK];
+
+    block_read(fs_device, inode->data.indirect, indirect_block);
+
+    return indirect_block[index];
+  }
+
+  index -= PTRS_PER_BLOCK;
+  if((size_t)index < PTRS_PER_BLOCK * PTRS_PER_BLOCK){
+    block_sector_t double_indirect_block[PTRS_PER_BLOCK];
+
+    block_read(fs_device, inode->data.double_indirect, double_indirect_block);
+
+    block_sector_t indirect_sector = double_indirect_block[index / PTRS_PER_BLOCK];
+    if(indirect_sector == 0){
+      return (block_sector_t) -1;
+    }
+
+    block_sector_t indirect_block[PTRS_PER_BLOCK];
+    block_read(fs_device, indirect_sector, indirect_block);
+
+    return indirect_block[index % PTRS_PER_BLOCK];
+  }
+
+  return (block_sector_t) -1;
 }
 
 /* List of open inodes, so that opening a single inode twice
@@ -64,40 +118,52 @@
    device.
    Returns true if successful.
    Returns false if memory or disk allocation fails. */
-bool inode_create (block_sector_t sector, off_t length)
+bool inode_create (block_sector_t sector, off_t length, bool is_dir)
 {
-  struct inode_disk *disk_inode = NULL;
-  bool success = false;
-
   ASSERT (length >= 0);
 
-  /* If this assertion fails, the inode structure is not exactly
-     one sector in size, and you should fix that. */
-  ASSERT (sizeof *disk_inode == BLOCK_SECTOR_SIZE);
+  struct inode_disk *disk_inode = calloc (1, sizeof *disk_inode);
+  if (disk_inode == NULL){
+    dprintf("[inode_create] Failed to allocate disk_inode\n");
+    return false;
+  }
 
-  disk_inode = calloc (1, sizeof *disk_inode);
-  if (disk_inode != NULL)
-    {
-      size_t sectors = bytes_to_sectors (length);
-      disk_inode->length = length;
-      disk_inode->magic = INODE_MAGIC;
-      disk_inode->is_symlink = false;
-      if (free_map_allocate (sectors, &disk_inode->start))
-        {
-          block_write (fs_device, sector, disk_inode);
-          if (sectors > 0)
-            {
-              static char zeros[BLOCK_SECTOR_SIZE];
-              size_t i;
+  ASSERT (sizeof *disk_inode == BLOCK_SECTOR_SIZE);
 
-              for (i = 0; i < sectors; i++)
-                block_write (fs_device, disk_inode->start + i, zeros);
-            }
-          success = true;
-        }
-      free (disk_inode);
-    }
-  return success;
+  dprintf("[inode_create] Creating inode at sector %d with length %d, is_dir=%d\n", (int)sector, (int)length, is_dir);
+  
+  disk_inode->length = 0; // Start at 0, will grow via inode_resize
+  disk_inode->magic = INODE_MAGIC;
+  disk_inode->is_symlink = false;
+  disk_inode->is_dir = is_dir;
+
+  struct inode tmp_inode;
+  memset(&tmp_inode, 0, sizeof tmp_inode);
+  tmp_inode.data = *disk_inode;
+
+  dprintf("[inode_create] Before inode_resize: tmp_inode length=%d\n", (int)tmp_inode.data.length);
+  
+  // Use inode_resize to allocate and initialize sectors
+  if (!inode_resize(&tmp_inode, length)) {
+    dprintf("[inode_create] inode_resize failed\n");
+    free(disk_inode);
+    return false;
+  }
+
+  dprintf("[inode_create] After inode_resize: tmp_inode length=%d\n", (int)tmp_inode.data.length);
+
+  // Copy updated inode_disk structure back
+  *disk_inode = tmp_inode.data;
+
+  dprintf("[inode_create] After resize copy in disk_inode length=%d\n", disk_inode->length);
+
+  // Write inode to disk
+  dprintf("[inode_create] Writing inode to sector %d\n", (int)sector);
+  block_write(fs_device, sector, disk_inode);
+
+  free(disk_inode);
+  dprintf("[inode_create] Inode creation complete\n");
+  return true;
 }
 
 /* Reads an inode from SECTOR
@@ -116,6 +182,7 @@
       if (inode->sector == sector)
         {
           inode_reopen (inode);
+	  dprintf("[inode_open] At sector %d found length %d\n", (int)inode->sector, (int)inode->data.length);
           return inode;
         }
     }
@@ -132,6 +199,7 @@
   inode->deny_write_cnt = 0;
   inode->removed = false;
   block_read (fs_device, inode->sector, &inode->data);
+  dprintf("[inode_open] At sector %d found length %d\n", (int)inode->sector, (int)inode->data.length);
   return inode;
 }
 
@@ -164,12 +232,13 @@
       /* Remove from inode list and release lock. */
       list_remove (&inode->elem);
 
+      block_write (fs_device, inode->sector, &inode->data);
+
       /* Deallocate blocks if removed. */
       if (inode->removed)
         {
           free_map_release (inode->sector, 1);
-          free_map_release (inode->data.start,
-                            bytes_to_sectors (inode->data.length));
+          inode_deallocate_sectors(&(inode->data));
         }
 
       free (inode);
@@ -194,6 +263,9 @@
   off_t bytes_read = 0;
   uint8_t *bounce = NULL;
 
+  dprintf("[inode_read_at] Starting read: inode sector=%d, inode length=%d, requested size=%d, start offset=%d\n",
+	  (int)inode->sector, (int)inode_length(inode), (int)size, (int)offset);
+
   while (size > 0)
     {
       /* Disk sector to read, starting byte offset within sector. */
@@ -207,12 +279,19 @@
 
       /* Number of bytes to actually copy out of this sector. */
       int chunk_size = size < min_left ? size : min_left;
-      if (chunk_size <= 0)
+      if (chunk_size <= 0){
+	dprintf("[inode_read_at] Breaking: chunk_size <= 0 (inode_left=%d, sector_left=%d, size=%d)\n",
+		(int)inode_left, (int)sector_left, (int)size);
         break;
+      }
 
+      dprintf("[inode_read_at] Reading sector %d at offset %d, chunk size %d\n",
+	      sector_idx, sector_ofs, chunk_size);
+      
       if (sector_ofs == 0 && chunk_size == BLOCK_SECTOR_SIZE)
         {
           /* Read full sector directly into caller's buffer. */
+	  dprintf("[inode_read_at] Full sector read into buffer\n");
           block_read (fs_device, sector_idx, buffer + bytes_read);
         }
       else
@@ -222,9 +301,12 @@
           if (bounce == NULL)
             {
               bounce = malloc (BLOCK_SECTOR_SIZE);
-              if (bounce == NULL)
+              if (bounce == NULL){
+		dprintf("[inode_read_at] Bounce buffer malloc failed!\n");
                 break;
+	      }
             }
+	  dprintf("[inode_read_at] Partial sector read using bounce buffer\n");
           block_read (fs_device, sector_idx, bounce);
           memcpy (buffer + bytes_read, bounce + sector_ofs, chunk_size);
         }
@@ -236,6 +318,8 @@
     }
   free (bounce);
 
+  dprintf("[inode_read_at] Read %d bytes\n", (int)bytes_read);
+
   return bytes_read;
 }
 
@@ -254,19 +338,21 @@
   if (inode->deny_write_cnt)
     return 0;
 
+  off_t end_offset = offset + size;
+  if (end_offset > inode_length(inode)){
+    if (!inode_resize(inode, end_offset)){
+      return bytes_written;
+    }
+  }
+  
   while (size > 0)
     {
-      /* Sector to write, starting byte offset within sector. */
       block_sector_t sector_idx = byte_to_sector (inode, offset);
       int sector_ofs = offset % BLOCK_SECTOR_SIZE;
 
-      /* Bytes left in inode, bytes left in sector, lesser of the two. */
-      off_t inode_left = inode_length (inode) - offset;
       int sector_left = BLOCK_SECTOR_SIZE - sector_ofs;
-      int min_left = inode_left < sector_left ? inode_left : sector_left;
+      int chunk_size = size < sector_left ? size : sector_left;
 
-      /* Number of bytes to actually write into this sector. */
-      int chunk_size = size < min_left ? size : min_left;
       if (chunk_size <= 0)
         break;
 
@@ -337,3 +423,152 @@
   inode->data.is_symlink = is_symlink;
   block_write (fs_device, inode->sector, &inode->data);
 }
+
+bool inode_resize(struct inode *inode, off_t new_length){
+  if (new_length < inode->data.length){
+    //implement shrinking
+    return false;
+  }
+
+  off_t old_length = inode->data.length;
+  size_t old_sectors = bytes_to_sectors(old_length);
+  size_t new_sectors = bytes_to_sectors(new_length);
+
+  if (new_sectors > old_sectors){
+    for (size_t i = old_sectors; i < new_sectors; i++){
+      block_sector_t new_sector;
+      if(!free_map_allocate(1, &new_sector)){
+	return false;
+      }
+
+      static char zeros[BLOCK_SECTOR_SIZE];
+      block_write(fs_device, new_sector, zeros);
+
+      if (!inode_allocate_sector(&inode->data, i, new_sector)){
+	return false;
+      }
+    }
+  }
+
+  inode->data.length = new_length;
+
+  block_write(fs_device, inode->sector, &inode->data);
+
+  return true;
+}
+
+bool inode_allocate_sector(struct inode_disk *disk_inode, size_t index, block_sector_t new_sector){
+
+  static char zeros[BLOCK_SECTOR_SIZE];
+  
+  if ((size_t)index < DIRECT_BLOCKS){
+    disk_inode->direct[index] = new_sector;
+    return true;
+  }
+
+  index -= DIRECT_BLOCKS;
+
+  if ((size_t)index < PTRS_PER_BLOCK){
+    if (disk_inode->indirect == 0){
+      if (!free_map_allocate(1, &disk_inode->indirect)){
+	return false;
+      }
+      block_write(fs_device, disk_inode->indirect, zeros);
+    }
+
+    block_sector_t indirect_block[PTRS_PER_BLOCK];
+    block_read(fs_device, disk_inode->indirect, indirect_block);
+    indirect_block[index] = new_sector;
+    block_write(fs_device, disk_inode->indirect, indirect_block);
+    return true;
+  }
+
+  index -= PTRS_PER_BLOCK;
+  if ((size_t)index < PTRS_PER_BLOCK * PTRS_PER_BLOCK) {
+    if (disk_inode->double_indirect == 0) {
+      if (!free_map_allocate(1, &disk_inode->double_indirect)) return false;
+      block_write(fs_device, disk_inode->double_indirect, zeros);
+    }
+
+    block_sector_t outer_block[PTRS_PER_BLOCK];
+    block_read(fs_device, disk_inode->double_indirect, outer_block);
+
+    size_t outer_index = index / PTRS_PER_BLOCK;
+    size_t inner_index = index % PTRS_PER_BLOCK;
+
+    if (outer_block[outer_index] == 0) {
+      if (!free_map_allocate(1, &outer_block[outer_index])) return false;
+      block_write(fs_device, outer_block[outer_index], zeros);
+      block_write(fs_device, disk_inode->double_indirect, outer_block); // update outer block
+    }
+
+    block_sector_t inner_block[PTRS_PER_BLOCK];
+    block_read(fs_device, outer_block[outer_index], inner_block);
+    inner_block[inner_index] = new_sector;
+    block_write(fs_device, outer_block[outer_index], inner_block);
+    return true;
+  }
+
+  return false; // index too large
+}
+
+void inode_deallocate_sectors(struct inode_disk *disk_inode) {
+  //static char zeros[BLOCK_SECTOR_SIZE];
+  size_t num_sectors = bytes_to_sectors(disk_inode->length);
+
+  // 1. Direct blocks
+  size_t i = 0;
+  for (; i < DIRECT_BLOCKS && i < num_sectors; i++) {
+    if (disk_inode->direct[i] != 0)
+      free_map_release(disk_inode->direct[i], 1);
+  }
+
+  // 2. Indirect block
+  if (i < num_sectors && disk_inode->indirect != 0) {
+    block_sector_t indirect_block[PTRS_PER_BLOCK];
+    block_read(fs_device, disk_inode->indirect, indirect_block);
+
+    size_t indirect_count = num_sectors - i;
+    if (indirect_count > PTRS_PER_BLOCK) indirect_count = PTRS_PER_BLOCK;
+
+    for (size_t j = 0; j < indirect_count; j++) {
+      if (indirect_block[j] != 0)
+	free_map_release(indirect_block[j], 1);
+    }
+
+    free_map_release(disk_inode->indirect, 1);
+    i += indirect_count;
+  }
+
+  // 3. Double indirect block
+  if (i < num_sectors && disk_inode->double_indirect != 0) {
+    block_sector_t outer_block[PTRS_PER_BLOCK];
+    block_read(fs_device, disk_inode->double_indirect, outer_block);
+
+    size_t total_double = num_sectors - i;
+    size_t outer_limit = DIV_ROUND_UP(total_double, PTRS_PER_BLOCK);
+
+    for (size_t outer = 0; outer < outer_limit; outer++) {
+      if (outer_block[outer] != 0) {
+	block_sector_t inner_block[PTRS_PER_BLOCK];
+	block_read(fs_device, outer_block[outer], inner_block);
+
+	size_t inner_limit = total_double > PTRS_PER_BLOCK ? PTRS_PER_BLOCK : total_double;
+
+	for (size_t inner = 0; inner < inner_limit; inner++) {
+	  if (inner_block[inner] != 0)
+	    free_map_release(inner_block[inner], 1);
+	}
+
+	free_map_release(outer_block[outer], 1);
+	total_double -= inner_limit;
+      }
+    }
+
+    free_map_release(disk_inode->double_indirect, 1);
+  }
+}
+
+bool inode_is_dir(struct inode *inode){
+  return inode != NULL && inode->data.is_dir;
+}
diff -ruN aos_pintos/src/filesys/inode.h pintos-solution/src/filesys/inode.h
--- aos_pintos/src/filesys/inode.h	2025-04-28 15:48:15.672391363 +0000
+++ pintos-solution/src/filesys/inode.h	2025-04-28 03:48:05.966565857 +0000
@@ -6,9 +6,10 @@
 #include "devices/block.h"
 
 struct bitmap;
+struct inode_disk;
 
 void inode_init (void);
-bool inode_create (block_sector_t, off_t);
+bool inode_create (block_sector_t, off_t, bool is_dir);
 struct inode *inode_open (block_sector_t);
 struct inode *inode_reopen (struct inode *);
 block_sector_t inode_get_inumber (const struct inode *);
@@ -22,4 +23,10 @@
 bool inode_get_symlink (struct inode *inode);
 void inode_set_symlink (struct inode *inode, bool is_symlink);
 
+bool inode_resize(struct inode *inode, off_t new_length);
+void inode_deallocate_sectors(struct inode_disk *disk_inode);
+bool inode_allocate_sector(struct inode_disk *disk_inode, size_t index, block_sector_t new_sector);
+
+bool inode_is_dir(struct inode *inode);
+
 #endif /* filesys/inode.h */
diff -ruN aos_pintos/src/lib/kernel/bitmap.c pintos-solution/src/lib/kernel/bitmap.c
--- aos_pintos/src/lib/kernel/bitmap.c	2025-04-28 15:48:15.672391363 +0000
+++ pintos-solution/src/lib/kernel/bitmap.c	2025-04-28 03:49:47.574341709 +0000
@@ -318,8 +318,11 @@
   if (b->bit_cnt > 0)
     {
       off_t size = byte_cnt (b->bit_cnt);
+      printf("[bitmap_read] Attempting to read %d bytes into bitmap\n", (int)size);
       success = file_read_at (file, b->bits, size, 0) == size;
       b->bits[elem_cnt (b->bit_cnt) - 1] &= last_mask (b);
+      if (success)
+	printf("[bitmap_read] Read %d bytes\n", (int)size);
     }
   return success;
 }
diff -ruN aos_pintos/src/threads/init.c pintos-solution/src/threads/init.c
--- aos_pintos/src/threads/init.c	2025-04-28 15:48:15.680391395 +0000
+++ pintos-solution/src/threads/init.c	2025-04-27 21:48:39.470134580 +0000
@@ -36,6 +36,8 @@
 #include "devices/ide.h"
 #include "filesys/filesys.h"
 #include "filesys/fsutil.h"
+#include "vm/frame.h"
+#include "vm/swap.h"
 #endif
 
 /* Page directory with kernel mappings only. */
@@ -93,6 +95,7 @@
 
   /* Initialize memory system. */
   palloc_init (user_page_limit);
+  frame_table_init();
   malloc_init ();
   paging_init ();
 
@@ -124,6 +127,8 @@
   filesys_init (format_filesys);
 #endif
 
+  swap_init();
+
   printf ("Boot complete.\n");
 
   /* Run actions specified on kernel command line. */
diff -ruN aos_pintos/src/threads/interrupt.c pintos-solution/src/threads/interrupt.c
--- aos_pintos/src/threads/interrupt.c	2025-04-28 15:48:15.680391395 +0000
+++ pintos-solution/src/threads/interrupt.c	2025-04-27 21:48:39.470134580 +0000
@@ -339,7 +339,9 @@
 
       in_external_intr = true;
       yield_on_return = false;
-    }
+    }else{
+    thread_current()->user_esp = frame->esp;
+  }
 
   /* Invoke the interrupt's handler. */
   handler = intr_handlers[frame->vec_no];
diff -ruN aos_pintos/src/threads/palloc.c pintos-solution/src/threads/palloc.c
--- aos_pintos/src/threads/palloc.c	2025-04-28 15:48:15.680391395 +0000
+++ pintos-solution/src/threads/palloc.c	2025-04-27 21:48:39.470134580 +0000
@@ -72,17 +72,19 @@
   void *pages;
   size_t page_idx;
 
-  if (page_cnt == 0)
+  if (page_cnt == 0){
     return NULL;
-
+  }
+    
   lock_acquire (&pool->lock);
   page_idx = bitmap_scan_and_flip (pool->used_map, 0, page_cnt, false);
   lock_release (&pool->lock);
 
   if (page_idx != BITMAP_ERROR)
     pages = pool->base + PGSIZE * page_idx;
-  else
+  else{
     pages = NULL;
+  }
 
   if (pages != NULL)
     {
diff -ruN aos_pintos/src/threads/thread.c pintos-solution/src/threads/thread.c
--- aos_pintos/src/threads/thread.c	2025-04-28 15:48:15.680391395 +0000
+++ pintos-solution/src/threads/thread.c	2025-04-27 21:48:39.470134580 +0000
@@ -13,6 +13,7 @@
 #include "threads/vaddr.h"
 #ifdef USERPROG
 #include "userprog/process.h"
+#include "vm/page.h"
 #endif
 
 /* Random value for struct thread's `magic' member.
@@ -321,9 +322,7 @@
 int thread_get_priority (void) { return thread_current ()->priority; }
 
 /* Sets the current thread's nice value to NICE. */
-void thread_set_nice (int nice UNUSED)
-{ /* Not yet implemented. */
-}
+void thread_set_nice (int nice UNUSED) { /* Not yet implemented. */ }
 
 /* Returns the current thread's nice value. */
 int thread_get_nice (void)
@@ -346,6 +345,43 @@
   return 0;
 }
 
+/* Iterate through all_list to find the thread with tid. Return the tid_t
+ * received. Return NULL if thread not found */
+struct thread *get_thread_from_tid (tid_t tid)
+{
+  enum intr_level old_level = intr_disable ();
+
+  // Finding the child thread
+  struct thread *t = NULL;
+  for (struct list_elem *e = list_begin (&all_list); e != list_end (&all_list);
+       e = list_next (e))
+    {
+      t = list_entry (e, struct thread, allelem);
+      if (t->tid == tid)
+        break;
+    }
+
+  intr_set_level (old_level); // Restore interrupts
+
+  return t;
+}
+
+/* Set child thread's parent, and parent thread's list of child threads */
+void set_parent_child_thread (struct thread *t_p, tid_t child_tid)
+{
+  struct thread *child = get_thread_from_tid (child_tid);
+  if (child == NULL)
+    return;
+
+  child->parent = t_p;
+  struct child *child_struct = palloc_get_page (PAL_ZERO);
+  child_struct->tid = child_tid;
+  child_struct->waited_on = false;
+  child->child_info = child_struct;
+  sema_init (&child_struct->wait_sema, 0);
+  list_push_back (&t_p->children, &child_struct->child_elem);
+}
+
 /* Idle thread.  Executes when no other thread is ready to run.
 
    The idle thread is initially put on the ready list by
@@ -429,6 +465,16 @@
   t->priority = priority;
   t->magic = THREAD_MAGIC;
 
+  // Initializing for user process
+  list_init (&t->children);
+
+  page_table_init(t);
+
+  // Initializing file descriptors.
+  for (int i = 0; i < MAX_FILES; i++)
+    t->files[i] = NULL;
+  t->executable = NULL;
+
   old_level = intr_disable ();
   list_push_back (&all_list, &t->allelem);
   intr_set_level (old_level);
diff -ruN aos_pintos/src/threads/thread.h pintos-solution/src/threads/thread.h
--- aos_pintos/src/threads/thread.h	2025-04-28 15:48:15.680391395 +0000
+++ pintos-solution/src/threads/thread.h	2025-04-27 21:48:39.470134580 +0000
@@ -4,6 +4,7 @@
 #include <debug.h>
 #include <list.h>
 #include <stdint.h>
+#include "threads/synch.h"
 
 /* States in a thread's life cycle. */
 enum thread_status
@@ -17,13 +18,15 @@
 /* Thread identifier type.
    You can redefine this to whatever type you like. */
 typedef int tid_t;
-#define TID_ERROR ((tid_t) -1) /* Error value for tid_t. */
+#define TID_ERROR ((tid_t) - 1) /* Error value for tid_t. */
 
 /* Thread priorities. */
 #define PRI_MIN 0      /* Lowest priority. */
 #define PRI_DEFAULT 31 /* Default priority. */
 #define PRI_MAX 63     /* Highest priority. */
 
+#define MAX_FILES 32
+
 /* A kernel thread or user process.
 
    Each thread structure is stored in its own 4 kB page.  The
@@ -100,10 +103,30 @@
   uint32_t *pagedir; /* Page directory. */
 #endif
 
+  struct thread *parent;     /* Child thread */
+  struct list children;      /* List of struct child */
+  struct child *child_info;  /* Semaphore for wait/exit synchronization. */
+
+  struct file *files[MAX_FILES]; /* Array of available FDs */
+  struct file *executable;        /* Executable file */
+
+  struct list page_table;
+  void *user_esp;
+
   /* Owned by thread.c. */
   unsigned magic; /* Detects stack overflow. */
 };
 
+// Structure to hold child process information.
+struct child
+{
+  struct list_elem child_elem; /* For the parent's list of children. */
+  int exit_status;             /* Exit status of the child. */
+  tid_t tid;                   /* Child's TID */
+  struct semaphore wait_sema;  /* Semaphore for wait/exit synchronization. */
+  bool waited_on;              /* Has the parent waited on this child? */
+};
+
 /* If false (default), use round-robin scheduler.
    If true, use multi-level feedback queue scheduler.
    Controlled by kernel command-line option "-o mlfqs". */
@@ -140,4 +163,7 @@
 int thread_get_recent_cpu (void);
 int thread_get_load_avg (void);
 
+struct thread *get_thread_from_tid (tid_t tid);
+void set_parent_child_thread (struct thread *t_p, tid_t child_tid);
+
 #endif /* threads/thread.h */
diff -ruN aos_pintos/src/userprog/exception.c pintos-solution/src/userprog/exception.c
--- aos_pintos/src/userprog/exception.c	2025-04-28 15:48:15.680391395 +0000
+++ pintos-solution/src/userprog/exception.c	2025-04-27 21:48:39.470134580 +0000
@@ -1,9 +1,16 @@
 #include "userprog/exception.h"
 #include <inttypes.h>
 #include <stdio.h>
+#include <string.h>
 #include "userprog/gdt.h"
 #include "threads/interrupt.h"
 #include "threads/thread.h"
+#include "threads/vaddr.h"
+#include "userprog/pagedir.h"
+#include "userprog/syscall.h"
+#include "vm/frame.h"
+#include "vm/page.h"
+#include "vm/swap.h"
 
 /* Number of page faults processed. */
 static long long page_fault_cnt;
@@ -127,7 +134,7 @@
      See [IA32-v2a] "MOV--Move to/from Control Registers" and
      [IA32-v3a] 5.15 "Interrupt 14--Page Fault Exception
      (#PF)". */
-  asm("movl %%cr2, %0" : "=r"(fault_addr));
+  asm ("movl %%cr2, %0" : "=r"(fault_addr));
 
   /* Turn interrupts back on (they were only off so that we could
      be assured of reading CR2 before it changed). */
@@ -141,14 +148,17 @@
   write = (f->error_code & PF_W) != 0;
   user = (f->error_code & PF_U) != 0;
 
-  /* To implement virtual memory, delete the rest of the function
-     body, and replace it with code that brings in the page to
-     which fault_addr refers. */
-  printf ("Page fault at %p: %s error %s page in %s context.\n", fault_addr,
-          not_present ? "not present" : "rights violation",
-          write ? "writing" : "reading", user ? "user" : "kernel");
-
-  printf ("There is no crying in Pintos!\n");
-
+  if(!is_user_vaddr(fault_addr) || fault_addr == NULL){
+    exit(-1);
+  }
+
+  if (user && not_present){
+    if(!page_in (fault_addr, write)){
+      exit(-1);
+      thread_exit();
+    }
+    return;
+  }
+  exit(-1);
   kill (f);
 }
diff -ruN aos_pintos/src/userprog/process.c pintos-solution/src/userprog/process.c
--- aos_pintos/src/userprog/process.c	2025-04-28 15:48:15.680391395 +0000
+++ pintos-solution/src/userprog/process.c	2025-04-27 21:48:39.470134580 +0000
@@ -17,9 +17,13 @@
 #include "threads/palloc.h"
 #include "threads/thread.h"
 #include "threads/vaddr.h"
+#include "threads/synch.h"
+#include "userprog/syscall.h"
+#include "vm/frame.h"
+#include "vm/page.h"
 
 static thread_func start_process NO_RETURN;
-static bool load (const char *cmdline, void (**eip) (void), void **esp);
+static bool load (struct cmdline_args *args, void (**eip) (void), void **esp);
 
 /* Starts a new thread running a user program loaded from
    FILENAME.  The new thread may be scheduled (and may even exit)
@@ -27,28 +31,74 @@
    thread id, or TID_ERROR if the thread cannot be created. */
 tid_t process_execute (const char *file_name)
 {
-  char *fn_copy;
   tid_t tid;
+  char *save_ptr, *token;
+  struct cmdline_args *args; // struct for storing all arguments
+
+  /* Get page for storing arguments */
+  args = palloc_get_page (0);
+  if (args == NULL)
+    {
+      return TID_ERROR;
+    }
 
   /* Make a copy of FILE_NAME.
      Otherwise there's a race between the caller and load(). */
-  fn_copy = palloc_get_page (0);
-  if (fn_copy == NULL)
-    return TID_ERROR;
-  strlcpy (fn_copy, file_name, PGSIZE);
+  args->fn_copy = palloc_get_page (0);
+  if (args->fn_copy == NULL)
+    {
+      palloc_free_page (args);
+      return TID_ERROR;
+    }
+  strlcpy (args->fn_copy, file_name, PGSIZE);
+
+  /* Parsing the arguments */
+  token = strtok_r (args->fn_copy, " ", &save_ptr);
+  args->file_name = token;
+  args->argv[0] = token;
+
+  int count = 1;
+  while (token != NULL && count < MAX_ARGS - 1)
+    {
+      token = strtok_r (NULL, " ", &save_ptr);
+      if (token != NULL)
+        args->argv[count++] = token;
+    }
+  args->argv[count] = NULL;
+  args->argc = count;
+
+  sema_init (&args->load_sema, 0); // Initialize load semaphore
+  args->load_flag = false;         // Initialize load flag
 
   /* Create a new thread to execute FILE_NAME. */
-  tid = thread_create (file_name, PRI_DEFAULT, start_process, fn_copy);
+  tid = thread_create (args->file_name, PRI_DEFAULT, start_process, args);
   if (tid == TID_ERROR)
-    palloc_free_page (fn_copy);
+    {
+      palloc_free_page (args->fn_copy);
+      palloc_free_page (args);
+      return TID_ERROR;
+    }
+
+  // Set parent and child in threads
+  struct thread *t_child = get_thread_from_tid (tid);
+  set_parent_child_thread (thread_current (), t_child->tid);
+
+  sema_down (&args->load_sema); // Wait until load semaphore is released
+
+  if (!args->load_flag)
+    tid = TID_ERROR;
+
+  palloc_free_page (args->fn_copy);
+  palloc_free_page (args);
+
   return tid;
 }
 
 /* A thread function that loads a user process and starts it
    running. */
-static void start_process (void *file_name_)
+static void start_process (void *args_)
 {
-  char *file_name = file_name_;
+  struct cmdline_args *args = args_;
   struct intr_frame if_;
   bool success;
 
@@ -57,10 +107,12 @@
   if_.gs = if_.fs = if_.es = if_.ds = if_.ss = SEL_UDSEG;
   if_.cs = SEL_UCSEG;
   if_.eflags = FLAG_IF | FLAG_MBS;
-  success = load (file_name, &if_.eip, &if_.esp);
+  success = load (args, &if_.eip, &if_.esp);
+
+  args->load_flag = success;
+  sema_up (&args->load_sema); // Release load semaphore
 
   /* If load failed, quit. */
-  palloc_free_page (file_name);
   if (!success)
     thread_exit ();
 
@@ -70,7 +122,7 @@
      arguments on the stack in the form of a `struct intr_frame',
      we just point the stack pointer (%esp) to our stack frame
      and jump to it. */
-  asm volatile("movl %0, %%esp; jmp intr_exit" : : "g"(&if_) : "memory");
+  asm volatile ("movl %0, %%esp; jmp intr_exit" : : "g"(&if_) : "memory");
   NOT_REACHED ();
 }
 
@@ -83,7 +135,37 @@
 
    This function will be implemented in problem 2-2.  For now, it
    does nothing. */
-int process_wait (tid_t child_tid UNUSED) { return -1; }
+int process_wait (tid_t child_tid UNUSED)
+{
+  struct thread *cur = thread_current ();
+  struct child *child = NULL;
+
+  // Find the child thread from its parent threads
+  for (struct list_elem *e = list_begin (&cur->children);
+       e != list_end (&cur->children); e = list_next (e))
+    {
+      child = list_entry (e, struct child, child_elem);
+      if (child->tid == child_tid)
+        break;
+    }
+
+  // Fail if no child process with the tid is found or if the child thread is
+  // already being waited
+  if (child == NULL || child->waited_on)
+    return -1;
+
+  child->waited_on = true;
+
+  list_remove (&child->child_elem); // Remove the exited child process from the
+                                    // child thread list
+
+  sema_down (&child->wait_sema); // Waiting for the child to exit
+
+  int exit_status = child->exit_status; // Storing the child's exit status
+  palloc_free_page (child);
+
+  return exit_status; // Returning child's exit status
+}
 
 /* Free the current process's resources. */
 void process_exit (void)
@@ -91,6 +173,28 @@
   struct thread *cur = thread_current ();
   uint32_t *pd;
 
+  // Clean up any remaining children.  This is the key addition.
+  struct list_elem *e;
+  while (!list_empty (&cur->children))
+    {
+      e = list_pop_front (&cur->children);
+      struct child *child = list_entry (e, struct child, child_elem);
+
+      list_remove (&child->child_elem); // remove from parent's child list
+      palloc_free_page (child);         // Free child's thread.
+    }
+
+  // Close all open files
+  clear_all_files(cur);
+
+  // Allow waiting parent to continue (if any)
+  sema_up (&cur->child_info->wait_sema);
+
+  if (cur->executable != NULL)
+    {
+      file_close (cur->executable);
+    }
+
   /* Destroy the current process's page directory and switch back
      to the kernel-only page directory. */
   pd = cur->pagedir;
@@ -187,7 +291,7 @@
 #define PF_W 2 /* Writable. */
 #define PF_R 4 /* Readable. */
 
-static bool setup_stack (void **esp);
+static bool setup_stack (void **esp, const struct cmdline_args *args);
 static bool validate_segment (const struct Elf32_Phdr *, struct file *);
 static bool load_segment (struct file *file, off_t ofs, uint8_t *upage,
                           uint32_t read_bytes, uint32_t zero_bytes,
@@ -197,7 +301,7 @@
    Stores the executable's entry point into *EIP
    and its initial stack pointer into *ESP.
    Returns true if successful, false otherwise. */
-bool load (const char *file_name, void (**eip) (void), void **esp)
+bool load (struct cmdline_args *args, void (**eip) (void), void **esp)
 {
   struct thread *t = thread_current ();
   struct Elf32_Ehdr ehdr;
@@ -213,10 +317,11 @@
   process_activate ();
 
   /* Open executable file. */
-  file = filesys_open (file_name);
+  file = filesys_open (args->file_name);
+
   if (file == NULL)
     {
-      printf ("load: %s: open failed\n", file_name);
+      printf ("load: %s: open failed\n", args->file_name);
       goto done;
     }
 
@@ -226,7 +331,7 @@
       ehdr.e_machine != 3 || ehdr.e_version != 1 ||
       ehdr.e_phentsize != sizeof (struct Elf32_Phdr) || ehdr.e_phnum > 1024)
     {
-      printf ("load: %s: error loading executable\n", file_name);
+      printf ("load: %s: error loading executable\n", args->file_name);
       goto done;
     }
 
@@ -291,7 +396,7 @@
     }
 
   /* Set up stack. */
-  if (!setup_stack (esp))
+  if (!setup_stack (esp, args))
     goto done;
 
   /* Start address. */
@@ -300,8 +405,16 @@
   success = true;
 
 done:
-  /* We arrive here whether the load is successful or not. */
-  file_close (file);
+  if (success)
+    {
+      file_deny_write (file);
+      t->executable = file;
+    }
+  else
+    {
+      file_close (file);
+      t->executable = NULL;
+      }
   return success;
 }
 
@@ -374,7 +487,9 @@
   ASSERT ((read_bytes + zero_bytes) % PGSIZE == 0);
   ASSERT (pg_ofs (upage) == 0);
   ASSERT (ofs % PGSIZE == 0);
-
+  
+  struct thread *t = thread_current();
+  
   file_seek (file, ofs);
   while (read_bytes > 0 || zero_bytes > 0)
     {
@@ -385,49 +500,95 @@
       size_t page_zero_bytes = PGSIZE - page_read_bytes;
 
       /* Get a page of memory. */
-      uint8_t *kpage = palloc_get_page (PAL_USER);
-      if (kpage == NULL)
+      struct page_entry *p = page_allocate(upage, writable);
+      if (!p){
         return false;
+      }
+	
+      if(page_read_bytes > 0){
+	p->file = file;
+	p->file_offset = ofs;
+	p->read_bytes = page_read_bytes;
+      }
 
-      /* Load this page. */
-      if (file_read (file, kpage, page_read_bytes) != (int) page_read_bytes)
-        {
-          palloc_free_page (kpage);
-          return false;
-        }
-      memset (kpage + page_read_bytes, 0, page_zero_bytes);
-
-      /* Add the page to the process's address space. */
-      if (!install_page (upage, kpage, writable))
-        {
-          palloc_free_page (kpage);
-          return false;
-        }
-
-      /* Advance. */
       read_bytes -= page_read_bytes;
       zero_bytes -= page_zero_bytes;
+      ofs += page_read_bytes;
       upage += PGSIZE;
     }
+
   return true;
 }
 
 /* Create a minimal stack by mapping a zeroed page at the top of
    user virtual memory. */
-static bool setup_stack (void **esp)
+static bool setup_stack (void **esp, const struct cmdline_args *args)
 {
   uint8_t *kpage;
   bool success = false;
-
-  kpage = palloc_get_page (PAL_USER | PAL_ZERO);
-  if (kpage != NULL)
+  void *upage = ((uint8_t *) PHYS_BASE) - PGSIZE;
+  
+  struct page_entry *stack_page = page_allocate(upage, true);
+  if (stack_page == NULL)
+    return success;
+
+  struct frame_entry *f = frame_alloc(stack_page);
+  if(f == NULL){
+    return success;
+  }
+
+  kpage = f->base;
+  
+  success = install_page (upage, kpage, true);
+  if (!success)
+    {
+      page_deallocate(upage);
+      return success;
+    }
+  
+  stack_page->upage = upage;
+  stack_page->type = PAGE_STACK;
+  stack_page->writable = true;
+  stack_page->frame = f;
+
+  frame_unlock(f);
+  /* Pushing arguments to stack */
+  uint8_t *tos = PHYS_BASE;   // Top of stack
+  char *args_ptr[args->argc]; // pointers to arguments in the stack
+  size_t args_len;
+  
+  for (int i = args->argc - 1; i >= 0; i--)
     {
-      success = install_page (((uint8_t *) PHYS_BASE) - PGSIZE, kpage, true);
-      if (success)
-        *esp = PHYS_BASE;
-      else
-        palloc_free_page (kpage);
+      args_len = strlen (args->argv[i]) + 1; // + 1 for null termination
+      tos -= args_len;
+      memcpy (tos, args->argv[i], args_len);
+      args_ptr[i] = (char *) tos;
     }
+  tos = (uint8_t *) ((uintptr_t) tos & ~3); // Adding 0 for word-align
+  
+  tos -= sizeof (char *); // Adding null pointer sentinel
+  *(char **) tos = NULL;
+  
+  for (int i = args->argc - 1; i >= 0; i--) // Storing argument addresses
+    {
+      tos -= sizeof (char *);
+      *(char **) tos = args_ptr[i];
+    }
+
+  tos -= sizeof (char **); // Storing argument array ptr
+  *(char ***) tos = (char **) (tos + sizeof (char **));
+
+  tos -= sizeof (int); // Storing argc
+  *(int *) tos = args->argc;
+
+  tos -= sizeof (void *); // Storing return address
+  *(void **) tos = NULL;
+
+  *esp = tos;
+
+  // hex_dump((uintptr_t) tos, (void *)tos, LOADER_PHYS_BASE - (uintptr_t) tos,
+  // true); // Debugging
+
   return success;
 }
 
diff -ruN aos_pintos/src/userprog/process.h pintos-solution/src/userprog/process.h
--- aos_pintos/src/userprog/process.h	2025-04-28 15:48:15.680391395 +0000
+++ pintos-solution/src/userprog/process.h	2025-04-27 21:48:39.470134580 +0000
@@ -2,10 +2,26 @@
 #define USERPROG_PROCESS_H
 
 #include "threads/thread.h"
+#include "threads/synch.h"
+
+#define MAX_ARGS 32 // Defining a maximum number of arguments
 
 tid_t process_execute (const char *file_name);
 int process_wait (tid_t);
 void process_exit (void);
 void process_activate (void);
 
+/* Structure to pass arguments to the new thread. */
+struct cmdline_args
+{
+  char *file_name;      // Executable name
+  char *argv[MAX_ARGS]; // Array of argument strings
+  int argc;             // Number of arguments
+
+  char *fn_copy; // ptr to the copied command line
+
+  struct semaphore load_sema; // Semaphore for synchronization while loading
+  bool load_flag;             // True if successfully loaded
+};
+
 #endif /* userprog/process.h */
diff -ruN aos_pintos/src/userprog/syscall.c pintos-solution/src/userprog/syscall.c
--- aos_pintos/src/userprog/syscall.c	2025-04-28 15:48:15.680391395 +0000
+++ pintos-solution/src/userprog/syscall.c	2025-04-27 21:48:39.470134580 +0000
@@ -2,18 +2,562 @@
 #include <stdio.h>
 #include <syscall-nr.h>
 #include "devices/block.h"
+#include "devices/input.h"
 #include "threads/interrupt.h"
 #include "threads/thread.h"
+#include "threads/vaddr.h"
+#include "userprog/pagedir.h"
+#include "devices/shutdown.h"
+#include <debug.h>
+#include <string.h>
+#include "userprog/process.h"
+#include "filesys/filesys.h"
+#include "filesys/file.h"
+#include "vm/page.h"
+#include "vm/frame.h"
 
 static void syscall_handler (struct intr_frame *);
 
+static void sys_halt (void);
+static void sys_exit (struct intr_frame *);
+static void sys_exec (struct intr_frame *);
+static void sys_wait (struct intr_frame *);
+static void sys_create (struct intr_frame *);
+static void sys_remove (struct intr_frame *);
+static void sys_open (struct intr_frame *);
+static void sys_filesize (struct intr_frame *);
+static void sys_read (struct intr_frame *);
+static void sys_write (struct intr_frame *);
+static void sys_seek (struct intr_frame *);
+static void sys_tell (struct intr_frame *);
+static void sys_close (struct intr_frame *);
+static void sys_symlink (struct intr_frame *);
+
+static int get_user (const uintptr_t uaddr, size_t size, void *dest);
+static bool is_user_ptr_valid (const uintptr_t ptr, size_t size);
+
+struct lock file_lock;
+
 void syscall_init (void)
 {
   intr_register_int (0x30, 3, INTR_ON, syscall_handler, "syscall");
+  lock_init (&file_lock);
 }
 
 static void syscall_handler (struct intr_frame *f UNUSED)
 {
-  printf ("system call!\n");
+  uint32_t syscall_num;
+  if (!is_user_vaddr (f->esp) ||
+      get_user ((uintptr_t) f->esp, sizeof (syscall_num), &syscall_num) == -1)
+    exit (-1);
+
+  switch (syscall_num)
+    {
+      case SYS_HALT: /* Halt the operating system. */
+        sys_halt ();
+        break;
+      case SYS_EXIT: /* Terminate this process. */
+        sys_exit (f);
+        break;
+      case SYS_EXEC: /* Start another process. */
+        sys_exec (f);
+        break;
+      case SYS_WAIT: /* Wait for a child process to die. */
+        sys_wait (f);
+        break;
+      case SYS_CREATE: /* Create a file. */
+        sys_create (f);
+        break;
+      case SYS_REMOVE: /* Delete a file. */
+        sys_remove (f);
+        break;
+      case SYS_OPEN: /* Open a file. */
+        sys_open (f);
+        break;
+      case SYS_FILESIZE: /* Obtain a file's size. */
+        sys_filesize (f);
+        break;
+      case SYS_READ: /* Read from a file. */
+        sys_read (f);
+        break;
+      case SYS_WRITE: /* Write to a file. */
+        sys_write (f);
+        break;
+      case SYS_SEEK: /* Change position in a file. */
+        sys_seek (f);
+        break;
+      case SYS_TELL: /* Report current position in a file. */
+        sys_tell (f);
+        break;
+      case SYS_CLOSE: /* Close a file. */
+        sys_close (f);
+        break;
+      case SYS_SYMLINK: /* Create soft link */
+        sys_symlink (f);
+        break;
+
+      default:
+        exit (-1);
+        break;
+    }
+}
+static void sys_halt (void) { shutdown_power_off (); }
+
+static void sys_exit (struct intr_frame *f)
+{
+  int status;
+  if (get_user ((uintptr_t) f->esp + 4, sizeof (int), &status) == -1)
+    {
+      exit (-1);
+      return;
+    }
+  exit (status);
+}
+
+/* Helper function used to exit with status */
+void exit (int status)
+{
+  struct thread *cur = thread_current ();
+  if (cur->child_info != NULL)
+    cur->child_info->exit_status = status;
+  printf ("%s: exit(%d)\n", cur->name, status);
+
   thread_exit ();
-}
\ No newline at end of file
+}
+
+static void sys_exec (struct intr_frame *f)
+{
+  char *cmd_line;
+  int buf_len = 128;
+  char buf[buf_len];
+
+  if (get_user ((uintptr_t) f->esp + 4, sizeof (char *), &cmd_line) == -1 ||
+      !is_user_vaddr (cmd_line))
+    {
+      exit (-1);
+      return;
+    }
+
+  if (get_user ((uintptr_t) cmd_line, buf_len, (void *) buf) == -1)
+    {
+      exit (-1);
+      return;
+    }
+  buf[buf_len - 1] = '\0'; // Null termination
+
+  tid_t tid = process_execute (buf);
+
+  if (tid == TID_ERROR)
+    f->eax = -1;
+  else
+    f->eax = tid;
+}
+
+static void sys_wait (struct intr_frame *f)
+{
+  tid_t pid;
+  if (get_user ((uintptr_t) f->esp + 4, sizeof (tid_t), &pid) == -1)
+    {
+      exit (-1);
+      return;
+    }
+  f->eax = process_wait (pid);
+}
+
+static void sys_create (struct intr_frame *f)
+{
+  char *file;
+  unsigned initial_size;
+  bool out;
+  if (get_user ((uintptr_t) f->esp + 4, sizeof (char *), &file) == -1 ||
+      get_user ((uintptr_t) f->esp + 8, sizeof (unsigned), &initial_size) == -1)
+    {
+      exit (-1);
+      return;
+    }
+
+  if (file == NULL || !is_user_ptr_valid ((uintptr_t) file, sizeof (char *)))
+    {
+      exit (-1);
+      return;
+    }
+
+  lock_acquire (&file_lock);
+  out = filesys_create (file, initial_size);
+  lock_release (&file_lock);
+
+  f->eax = out;
+}
+
+static void sys_remove (struct intr_frame *f)
+{
+  char *file;
+  bool out;
+  if (get_user ((uintptr_t) f->esp + 4, sizeof (char *), &file) == -1 ||
+      file == NULL || !is_user_ptr_valid ((uintptr_t) file, sizeof (char *)))
+    {
+      exit (-1);
+      return;
+    }
+
+  lock_acquire (&file_lock);
+  out = filesys_remove (file);
+  lock_release (&file_lock);
+
+  f->eax = out;
+}
+
+static void sys_open (struct intr_frame *f)
+{
+  char *file;
+  int fd = -1;
+  struct file *file_opened;
+  if (get_user ((uintptr_t) f->esp + 4, sizeof (char *), &file) == -1 ||
+      file == NULL || !is_user_ptr_valid ((uintptr_t) file, sizeof (char *)))
+    {
+      exit (-1);
+      return;
+    }
+
+  lock_acquire (&file_lock);
+  file_opened = filesys_open (file);
+  lock_release (&file_lock);
+
+  if (file_opened == NULL)
+    {
+      f->eax = -1;
+      return;
+    }
+
+  struct thread *cur = thread_current ();
+  for (int i = 2; i < MAX_FILES; i++)
+    {
+      if (cur->files[i] == NULL)
+        {
+          cur->files[i] = file_opened;
+          fd = i;
+          break;
+        }
+    }
+
+  if (fd == -1)
+    {
+      lock_acquire (&file_lock);
+      file_close (file_opened);
+      lock_release (&file_lock);
+    }
+
+  f->eax = fd;
+}
+
+static void sys_filesize (struct intr_frame *f)
+{
+  int fd;
+  if (get_user ((uintptr_t) f->esp + 4, sizeof (int), &fd) == -1)
+    {
+      exit (-1);
+      return;
+    }
+
+  if (fd < 0 || fd >= MAX_FILES || thread_current ()->files[fd] == NULL)
+    {
+      f->eax = -1;
+      return;
+    }
+
+  lock_acquire (&file_lock);
+  f->eax = file_length (thread_current ()->files[fd]);
+  lock_release (&file_lock);
+}
+
+static void sys_read (struct intr_frame *f)
+{
+  int fd;
+  void *buffer;
+  unsigned size;
+  int out;
+  if (get_user ((uintptr_t) f->esp + 4, sizeof (int), &fd) == -1 ||
+      get_user ((uintptr_t) f->esp + 8, sizeof (void *), &buffer) == -1 ||
+      get_user ((uintptr_t) f->esp + 12, sizeof (unsigned), &size) == -1)
+    {
+      exit (-1);
+      return;
+    }
+
+  // Ensure buffer is valid and does not wrap around
+  if (buffer == NULL || (uintptr_t) buffer + size < (uintptr_t) buffer)
+    {
+      exit (-1);
+      return;
+    }
+
+  // Touch each page to ensure it's loaded into memory (trigger page fault if needed)
+  uint8_t *buf_ptr = (uint8_t *) buffer;
+  for (unsigned offset = 0; offset < size; offset += PGSIZE)
+    {
+      uint8_t tmp;
+      if (get_user ((uintptr_t)(buf_ptr + offset), 1, &tmp) == -1)
+	{
+	  exit (-1);
+	  return;
+	}
+    }
+
+  if (size > 0)
+    {
+      uint8_t tmp;
+
+      if (get_user((uintptr_t)(buf_ptr + size - 1), 1, &tmp) == -1)
+	{
+	  exit(-1);
+	  return;
+	}
+    }
+
+  lock_acquire (&file_lock);
+
+  if (fd == 0) // STDIN_FILENO
+    {
+      uint8_t *byte_buf = (uint8_t *) buffer;
+      for (int i = 0; i < (int) size; i++)
+        {
+          byte_buf[i] = input_getc ();
+        }
+      out = size; // Set the return value to bytes read
+    }
+  else
+    {
+      struct thread *cur = thread_current ();
+      if (fd < 0 || fd >= MAX_FILES || cur->files[fd] == NULL)
+        {
+          lock_release (&file_lock);
+          f->eax = -1;
+          return;
+        }
+      // Read file
+      out = file_read (cur->files[fd], buffer, size);
+    }
+
+  lock_release (&file_lock);
+  f->eax = out; // Return number of bytes read
+}
+
+static void sys_write (struct intr_frame *f)
+{
+  int fd;
+  const void *buffer;
+  unsigned size;
+  int out;
+  // Retrieve the arguments using get_user
+  if (get_user ((uintptr_t) f->esp + 4, sizeof (int), &fd) == -1 ||
+      get_user ((uintptr_t) f->esp + 8, sizeof (void *), &buffer) == -1 ||
+      get_user ((uintptr_t) f->esp + 12, sizeof (unsigned), &size) == -1)
+    {
+      exit (-1); // Exit on invalid pointer
+      return;
+    }
+
+  if (!is_user_ptr_valid ((uintptr_t) buffer, size))
+    {
+      exit (-1);
+      return;
+    }
+
+  if (fd == 1) // STDOUT_FILENO
+    {
+      putbuf (buffer, size);
+      out = size;   // Set the return value to bytes written
+      f->eax = out; // Return number of bytes written
+      return;
+    }
+
+  lock_acquire (&file_lock);
+  struct thread *cur = thread_current ();
+
+  if (fd < 0 || fd >= MAX_FILES || cur->files[fd] == NULL) // Invalid fd
+    {
+      lock_release (&file_lock);
+      f->eax = -1;
+      return;
+    }
+
+  // write to file if fd is valid
+  out = file_write (cur->files[fd], buffer, size);
+
+  lock_release (&file_lock);
+  f->eax = out; // Return number of bytes written
+}
+
+static void sys_seek (struct intr_frame *f)
+{
+  int fd;
+  unsigned position;
+
+  if (get_user ((uintptr_t) f->esp + 4, sizeof (int), &fd) == -1 ||
+      get_user ((uintptr_t) f->esp + 8, sizeof (unsigned), &position) == -1)
+    {
+      exit (-1);
+      return;
+    }
+
+  struct thread *cur = thread_current ();
+
+  if (fd < 0 || fd >= MAX_FILES || cur->files[fd] == NULL) // Invalid fd
+    {
+      exit (-1);
+      return;
+    }
+
+  lock_acquire (&file_lock);
+  file_seek (cur->files[fd], position);
+  lock_release (&file_lock);
+}
+
+static void sys_tell (struct intr_frame *f)
+{
+  int fd;
+  unsigned out = 0;
+
+  if (get_user ((uintptr_t) f->esp + 4, sizeof (int), &fd) == -1)
+    {
+      exit (-1);
+      return;
+    }
+
+  struct thread *cur = thread_current ();
+  if (fd < 0 || fd >= MAX_FILES || cur->files[fd] == NULL) // Invalid fd
+    {
+      exit (-1);
+      return;
+    }
+
+  lock_acquire (&file_lock);
+  out = file_tell (cur->files[fd]);
+  lock_release (&file_lock);
+
+  f->eax = out; // Return the position.
+}
+
+static void sys_close (struct intr_frame *f)
+{
+  int fd;
+
+  if (get_user ((uintptr_t) f->esp + 4, sizeof (int), &fd) == -1)
+    {
+      exit (-1);
+      return;
+    }
+
+  struct thread *cur = thread_current ();
+  if (fd < 0 || fd >= MAX_FILES || cur->files[fd] == NULL) // Invalid fd
+    {
+      exit (-1);
+      return;
+    }
+
+  lock_acquire (&file_lock);
+  file_close (cur->files[fd]);
+  cur->files[fd] = NULL; // Clear the fd.
+  lock_release (&file_lock);
+}
+
+static void sys_symlink (struct intr_frame *f)
+{
+  char *target;
+  char *linkpath;
+
+  int out = -1; // Assuming failure (-1)
+
+  if (get_user ((uintptr_t) f->esp + 4, sizeof (char **), &target) == -1 ||
+      get_user ((uintptr_t) f->esp + 8, sizeof (char **), &linkpath) == -1)
+    {
+      exit (-1);
+      return;
+    }
+
+  if (target == NULL ||
+      !is_user_ptr_valid ((uintptr_t) target, sizeof (char *)))
+    {
+      exit (-1);
+      return;
+    }
+
+  if (linkpath == NULL ||
+      !is_user_ptr_valid ((uintptr_t) linkpath, sizeof (char *)))
+    {
+      exit (-1);
+      return;
+    }
+
+  lock_acquire (&file_lock);
+
+  // Check if target file can be opened
+  struct file *target_file = filesys_open (target);
+  if (target_file == NULL)
+    {
+      lock_release (&file_lock);
+      f->eax = -1;
+      return;
+    }
+  file_close (target_file);
+
+  if (filesys_symlink (target, linkpath))
+    out = 0;
+  lock_release (&file_lock);
+
+  f->eax = out;
+}
+
+/* Reads (size) bytes from uaddr to dest. Returns -1 if failed, 0 if successful
+ */
+static int get_user (const uintptr_t uaddr, size_t size, void *dest)
+{
+
+  if (!is_user_vaddr((void *)uaddr) || !is_user_vaddr ((void *) (uaddr + size - 1))){
+    return -1;
+  }
+  
+  if (!is_user_ptr_valid (uaddr, size)){
+    if(!page_in(uaddr, false)){
+      return -1;
+    }
+  }
+
+  memcpy (dest, (void *) uaddr, size);
+  return 0;
+}
+
+/* Check if the user pointer is in the correct size */
+static bool is_user_ptr_valid (const uintptr_t ptr, size_t size)
+{
+  
+  if ((void *) ptr == NULL)
+    return false;
+
+  // Is mappable to physical address?
+  void *pagedir_start = pagedir_get_page (thread_current ()->pagedir, (void *) ptr);
+  void *pagedir_end = pagedir_get_page (thread_current ()->pagedir, (void *) (ptr + size - 1));
+
+  if (pagedir_start == NULL || pagedir_end == NULL)
+    {
+      return false;
+    }
+  return true;
+}
+
+/* Clears all open files in a given thread. */
+void clear_all_files (struct thread *cur)
+{
+  //lock_acquire (&file_lock);
+
+  // Iterate all files in current thread
+  for (int i = 2; i < MAX_FILES; i++)
+    {
+      if (cur->files[i] != NULL)
+        {
+          file_close (cur->files[i]);
+          cur->files[i] = NULL;
+        }
+    }
+  //lock_release (&file_lock);
+}
diff -ruN aos_pintos/src/userprog/syscall.h pintos-solution/src/userprog/syscall.h
--- aos_pintos/src/userprog/syscall.h	2025-04-28 15:48:15.680391395 +0000
+++ pintos-solution/src/userprog/syscall.h	2025-04-27 21:48:39.470134580 +0000
@@ -2,7 +2,10 @@
 #define USERPROG_SYSCALL_H
 
 #include <stdbool.h>
+#include "threads/thread.h"
 
 void syscall_init (void);
+void exit (int status);
+void clear_all_files(struct thread *cur);
 
 #endif /* userprog/syscall.h */
diff -ruN aos_pintos/src/vm/frame.c pintos-solution/src/vm/frame.c
--- aos_pintos/src/vm/frame.c	2025-04-28 15:48:15.680391395 +0000
+++ pintos-solution/src/vm/frame.c	2025-04-27 21:48:39.470134580 +0000
@@ -0,0 +1,112 @@
+#include "vm/frame.h"
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdbool.h>
+
+#include "filesys/file.h"
+#include "threads/malloc.h"
+#include "threads/palloc.h"
+#include "threads/thread.h"
+#include "threads/synch.h"
+#include "devices/timer.h"
+#include "userprog/pagedir.h"
+#include "vm/swap.h"
+#include "lib/kernel/list.h"
+
+#define MAX_FRAMES 2048
+
+static struct frame_entry frame_table[MAX_FRAMES];
+static size_t frame_count = 0;
+
+static struct list frame_list;
+static struct lock frames_lock;
+
+void frame_table_init(void){
+  list_init(&frame_list);
+  lock_init(&frames_lock);
+
+  void *base;
+  while ((base = palloc_get_page(PAL_USER)) != NULL && frame_count < MAX_FRAMES) {
+    struct frame_entry *f = &frame_table[frame_count++];
+    f->base = base;
+    f->page = NULL;
+    f->owner = NULL;
+    lock_init (&f->lock);
+    list_push_back(&frame_list, &f->frame_elem);
+  }
+}
+
+struct frame_entry *frame_alloc(struct page_entry *page){
+  size_t try;
+  struct list_elem *e;
+
+  for(try = 0; try < 3; try++){
+    lock_acquire(&frames_lock);
+
+    for (e = list_begin(&frame_list); e != list_end(&frame_list); e = list_next(e)){
+      struct frame_entry *f_entry = list_entry(e, struct frame_entry, frame_elem);
+
+      if(!lock_try_acquire (&f_entry->lock)){
+	continue;
+      }
+      
+      if(f_entry->page == NULL){
+	f_entry->page = page;
+	lock_release(&frames_lock);
+	return f_entry;
+      }
+      lock_release(&f_entry->lock);
+    }
+
+    for(e = list_begin(&frame_list); e != list_end(&frame_list); e = list_next(e)){
+      struct frame_entry *f_entry = list_entry(e, struct frame_entry, frame_elem);
+
+      if(!lock_try_acquire (&f_entry->lock)){
+	continue;
+      }
+      
+      if(f_entry->page == NULL){
+	f_entry->page = page;
+	lock_release(&frames_lock);
+	return f_entry;
+      }
+
+      if(page_relevant(f_entry->page)){
+	lock_release(&f_entry->lock);
+	continue;
+      }
+
+      lock_release(&frames_lock);
+
+      if(!page_out(f_entry->page)){
+	lock_release(&f_entry->lock);
+	return NULL;
+      }
+
+      f_entry->page = page;
+      return f_entry;
+    }
+    lock_release(&frames_lock);
+    timer_msleep(1000);
+  }
+  return NULL;
+}
+
+void frame_lock(struct page_entry *p){
+  struct frame_entry *f = p->frame;
+  if(f != NULL){
+    lock_acquire(&f->lock);
+  }
+}
+
+void frame_free(struct frame_entry *f){
+  ASSERT (lock_held_by_current_thread(&f->lock));
+
+  f->page = NULL;
+  lock_release(&f->lock);
+}
+
+void frame_unlock(struct frame_entry *f){
+  ASSERT (lock_held_by_current_thread (&f->lock));
+  lock_release(&f->lock);
+}
diff -ruN aos_pintos/src/vm/frame.h pintos-solution/src/vm/frame.h
--- aos_pintos/src/vm/frame.h	2025-04-28 15:48:15.680391395 +0000
+++ pintos-solution/src/vm/frame.h	2025-04-27 21:48:39.470134580 +0000
@@ -0,0 +1,28 @@
+#ifndef VM_FRAME_H
+#define VM_FRAME_H
+
+#include "threads/synch.h"
+#include "lib/kernel/list.h"
+#include "threads/thread.h"
+#include "threads/palloc.h"
+#include "vm/page.h"
+
+struct frame_entry {
+  void *base;
+  struct page_entry *page;
+  struct lock lock;
+  struct thread *owner;
+  struct list_elem frame_elem;
+};
+
+void frame_table_init(void);
+
+struct frame_entry *frame_alloc(struct page_entry *page);
+
+void frame_free(struct frame_entry *f);
+
+void frame_lock(struct page_entry *p);
+
+void frame_unlock(struct frame_entry *f);
+
+#endif
diff -ruN aos_pintos/src/vm/page.c pintos-solution/src/vm/page.c
--- aos_pintos/src/vm/page.c	2025-04-28 15:48:15.680391395 +0000
+++ pintos-solution/src/vm/page.c	2025-04-27 21:48:39.470134580 +0000
@@ -0,0 +1,217 @@
+#include "vm/page.h"
+#include "threads/malloc.h"
+#include "threads/thread.h"
+#include "threads/synch.h"
+#include "userprog/pagedir.h"
+#include "vm/swap.h"
+#include "threads/vaddr.h"
+#include <string.h>
+#include <stdio.h>
+
+#define STACK_MAX (4 * 1024 * 1024)
+
+void page_table_init(struct thread *t){
+  list_init(&t->page_table);
+}
+
+struct page_entry *page_lookup(const void *addr){
+  struct list_elem *e;
+  struct thread *t = thread_current();
+  
+  for(e = list_begin(&t->page_table); e != list_end(&t->page_table); e = list_next(e)){
+    struct page_entry *entry = list_entry(e, struct page_entry, page_elem);
+    if (entry->upage == pg_round_down(addr)){
+      return entry;
+    }
+  }
+  
+  if (addr < PHYS_BASE) {
+    void *upage = pg_round_down(addr);
+
+    uintptr_t phys_base = (uintptr_t)PHYS_BASE;
+    uintptr_t stack_max = (uintptr_t)STACK_MAX;
+    uintptr_t upage_addr = (uintptr_t)upage;
+
+    /*if ((upage_addr > phys_base - stack_max) && ((uint8_t *)thread_current()->user_esp - 32 < addr)) {
+      return page_allocate(upage, true);
+      }*/
+
+    if ((uintptr_t)addr >= (uintptr_t)(PHYS_BASE) - STACK_MAX && (uintptr_t)addr < (uintptr_t)PHYS_BASE)  {
+
+      if ((uintptr_t)addr < (uintptr_t)thread_current()->user_esp - (PGSIZE/2)) {
+	exit(-1);
+      }
+      
+      return page_allocate(upage, true);
+    }
+    
+  }
+
+  return NULL;
+}
+
+bool page_in(void *fault_addr, bool write){
+  struct thread *t = thread_current();
+  void *upage = pg_round_down(fault_addr);
+  
+  // Find the page in the thread's page list
+  struct page_entry *p = page_lookup(fault_addr);
+
+  if(write){
+    if(!p->writable){
+      exit(-1);
+    }
+  }
+  
+  if (p == NULL) {
+    return false;
+  }
+
+  // Allocate a frame
+  p->frame = frame_alloc(p);
+  if (p->frame == NULL) {
+    return false;
+  }
+
+  if (p->frame == NULL || p->frame->base == NULL) {
+    printf("Invalid frame for page %p\n", p->upage);
+    frame_unlock(p->frame);
+    return false; // Return false if the frame is not valid
+  }
+
+  // Check if the page is already mapped, and skip the mapping if it is
+  if (pagedir_get_page(t->pagedir, p->upage) != NULL) {
+    // The page is already mapped, no need to map it again
+    frame_unlock(p->frame);
+    return false; // Return false without attempting to map the page
+  }
+
+  // Load the data into the frame
+  if (p->in_swap) {
+    swap_in(p);
+  } else if (p->file != NULL) {
+    off_t read_bytes = file_read_at (p->file, p->frame->base, p->read_bytes, p->file_offset);
+    off_t zero_bytes = PGSIZE - read_bytes;
+    memset ((uint8_t *)p->frame->base + read_bytes, 0, zero_bytes);
+  } else {
+    memset(p->frame->base, 0, PGSIZE);
+  }
+  
+  // Install the page into the page directory
+  if (!pagedir_set_page(t->pagedir, p->upage, p->frame->base, p->writable)) {
+    printf("pagedir_set_page failed for %p\n", upage);
+    frame_unlock(p->frame);
+    return false;
+  }
+
+  frame_unlock (p->frame);
+  return true;
+}
+
+bool page_out(struct page_entry *p){
+  bool dirty;
+  bool ok = false;
+
+  dirty = pagedir_is_dirty(p->thread->pagedir, (const void *) p->upage);
+
+  pagedir_clear_page(p->thread->pagedir, (void *) p->upage);
+
+  if(!dirty){
+    ok = true;
+  }
+
+  if(p->file == NULL){
+    ok = swap_out(p);
+  }else{
+    if(dirty){
+      if(!p->writable){
+	ok = swap_out(p);
+      }else{
+	ok = file_write_at(p->file, (const void *)p->frame->base, p->read_bytes, p->file_offset);
+      }
+    }
+  }
+
+  if(ok){
+    p->frame = NULL;
+  }
+  return ok;
+}
+
+bool page_relevant(struct page_entry *p){
+  if(pagedir_is_accessed(p->thread->pagedir, p->upage)){
+    pagedir_set_accessed(p->thread->pagedir, p->upage, false);
+  }
+  return pagedir_is_accessed(p->thread->pagedir, p->upage);
+}
+
+struct page_entry *page_allocate(void *uaddr, bool writable){
+  struct thread *t = thread_current();
+  struct page_entry *p = palloc_get_page(PAL_ZERO);
+  //struct page_entry *p = malloc(sizeof(struct page_entry));
+  
+  if(p != NULL){
+    p->upage = pg_round_down(uaddr);
+    p->writable = writable;
+    p->frame = NULL;
+
+    p->in_swap = false;
+    p->swap_index = (size_t) -1;
+
+    p->file = NULL;
+    p->file_offset = 0;
+    p->read_bytes = 0;
+    p->zero_bytes = 0;
+
+    p->type = PAGE_ZERO;
+    p->thread = t;
+
+    list_push_back(&t->page_table, &p->page_elem);
+  }
+
+  return p;
+}
+
+void page_deallocate(void *uaddr){
+  struct page_entry *p = page_lookup(uaddr);
+  frame_lock(p);
+  if(p->frame){
+    struct frame_entry *f = p->frame;
+    if(p->file && p->writable){
+      page_out(p);
+    }
+    frame_free(f);
+  }
+  list_remove(&p->page_elem);
+  palloc_free_page(p);
+  //free(p);
+}
+
+bool page_lock(const void *uaddr, bool write){
+  struct page_entry *p = page_lookup(uaddr);
+  if(p == NULL ||(!p->writable && write)){
+    return false;
+  }
+
+  frame_lock(p);
+  if(p->frame == NULL){
+    return(page_in(p, write) && pagedir_set_page(thread_current()->pagedir, p->upage, p->frame->base, p->writable));
+  }else{
+    return true;
+  }
+}
+
+void page_unlock(const void *uaddr){
+  struct page_entry *p = page_lookup(uaddr);
+  ASSERT (p != NULL);
+  frame_unlock(p->frame);
+}
+
+void page_table_destroy(struct thread *t){
+  struct list_elem *e;
+  while(!list_empty(&t->page_table)){
+    e = list_pop_front(&t->page_table);
+    struct page_entry *entry = list_entry(e, struct page_entry, page_elem);
+    free(entry);
+  }
+}
diff -ruN aos_pintos/src/vm/page.h pintos-solution/src/vm/page.h
--- aos_pintos/src/vm/page.h	2025-04-28 15:48:15.680391395 +0000
+++ pintos-solution/src/vm/page.h	2025-04-27 21:48:39.470134580 +0000
@@ -0,0 +1,43 @@
+#ifndef VM_PAGE_H
+#define VM_PAGE_H
+
+#include <list.h>
+#include <stdbool.h>
+#include "filesys/file.h"
+#include "threads/thread.h"
+#include "vm/frame.h"
+
+enum page_type {
+  PAGE_FILE,
+  PAGE_ZERO,
+  PAGE_STACK
+};
+
+struct page_entry {
+  void *upage;
+  struct thread *thread;
+  struct frame_entry *frame;
+  enum page_type type;
+  struct file *file;
+  off_t file_offset;
+  size_t read_bytes;
+  size_t zero_bytes;
+  bool writable;
+  bool in_swap;
+  size_t swap_index;
+  struct list_elem page_elem;
+};
+
+struct page_entry *page_lookup(const void *addr);
+
+void page_table_init(struct thread *t);
+struct page_entry *page_allocate(void *uaddr, bool writable);
+void page_deallocate(void *uaddr);
+bool page_in(void *fault_addr, bool write);
+bool page_out(struct page_entry *p);
+bool page_relevant(struct page_entry *p);
+bool page_lock(const void *uaddr, bool write);
+void page_unlock(const void *uaddr);
+void page_table_destroy(struct thread *t);
+
+#endif
diff -ruN aos_pintos/src/vm/swap.c pintos-solution/src/vm/swap.c
--- aos_pintos/src/vm/swap.c	2025-04-28 15:48:15.680391395 +0000
+++ pintos-solution/src/vm/swap.c	2025-04-27 21:48:39.470134580 +0000
@@ -0,0 +1,72 @@
+#include "vm/swap.h"
+#include "devices/block.h"
+#include "threads/vaddr.h"
+#include "threads/synch.h"
+#include "vm/frame.h"
+#include <bitmap.h>
+#include <debug.h>
+
+#define PAGE_SECTORS (PGSIZE/ BLOCK_SECTOR_SIZE)
+
+static struct block *swap_block;
+static struct bitmap *swap_bitmap;
+static struct lock swap_lock;
+
+void swap_init(void){
+  swap_block = block_get_role(BLOCK_SWAP);
+  size_t swap_size = block_size(swap_block) / PAGE_SECTORS;
+  swap_bitmap = bitmap_create(swap_size);
+  bitmap_set_all(swap_bitmap, false);
+  lock_init(&swap_lock);
+}
+
+bool swap_out(struct page_entry *p){
+  ASSERT(p != NULL);
+  ASSERT(p->frame != NULL);
+  //ASSERT(lock_held_by_current_thread(&p->frame->lock));
+
+  lock_acquire(&swap_lock);
+  size_t slot = bitmap_scan_and_flip(swap_bitmap, 0, 1, false);
+  lock_release(&swap_lock);
+
+  if(slot == BITMAP_ERROR){
+    return false;
+  }
+
+  size_t start_sector = slot * PAGE_SECTORS;
+  for(size_t i = 0; i < PAGE_SECTORS; i++){
+    block_write(swap_block, start_sector + i, (uint8_t *)p->frame->base + i * BLOCK_SECTOR_SIZE);
+  }
+
+  p->in_swap = true;
+  p->swap_index = slot;
+
+  return true;
+}
+
+void swap_in(struct page_entry *p){
+  size_t i;
+
+  ASSERT(p->frame != NULL);
+  //ASSERT(lock_held_by_current_thread (&p->frame->lock));
+  ASSERT(p->in_swap);
+  ASSERT(p->swap_index != (size_t) - 1);
+
+  size_t start_sector = p->swap_index * PAGE_SECTORS;
+  for(size_t i = 0; i < PAGE_SECTORS; i++){
+    block_read(swap_block, start_sector + i, (uint8_t *)p->frame->base + i * BLOCK_SECTOR_SIZE);
+  }
+
+  lock_acquire(&swap_lock);
+  bitmap_reset(swap_bitmap, p->swap_index);
+  lock_release(&swap_lock);
+
+  p->in_swap = false;
+  p->swap_index = (size_t)-1;
+}
+
+void swap_free(size_t swap_index){
+  lock_acquire(&swap_lock);
+  bitmap_reset(swap_bitmap, swap_index);
+  lock_release(&swap_lock);
+}
diff -ruN aos_pintos/src/vm/swap.h pintos-solution/src/vm/swap.h
--- aos_pintos/src/vm/swap.h	2025-04-28 15:48:15.680391395 +0000
+++ pintos-solution/src/vm/swap.h	2025-04-27 21:48:39.470134580 +0000
@@ -0,0 +1,8 @@
+#include <stdbool.h>
+#include "threads/synch.h"
+#include "vm/page.h"
+
+void swap_init(void);
+bool swap_out(struct page_entry *p);
+void swap_in(struct page_entry *p);
+void swap_free(size_t swap_index);
